# C

[toc]

## Array & Pointer
- 概念：一系列类型相同的元素组成的结构就是数组。`type name[number]`
- 指定初始化器（C99）
    ```c
    int arr[6] = {[2]=2,1,0};//将第3个元素初始化为2，1和0将按顺序初始化初始化器之后的元素
    ```
- 多维数组：就是元素是数组的数组，声明和初始化方法以二维数组为例：
    ```c
    int num[3][3] = 
    {
        {1,2,3},
        {4,5,6},
        (7,8,9)
    };
    ```
- 指针和数组，数组名就是数组首元素的地址`arr == &arr[0]`

    1. 赋值：数组名、带地址运算符（&）的变量名以及另一个指针都可以对指针进行赋值。
    2. 使用运算符“*”解引用，不必多说。
    3. 使用运算符“&”取得指针本身的地址。
    4. 指针与整数相加或者整数与指针相加，增加的具体数值是“数字×指向元素所需的字节数”：`arr + 1 == &arr[1]; *(arr + 1) == arr[1]`。
    5. 指针递增（++）和递减（--），如果指向的是数组中的一个元素，运算后将指向下一个或者上一个元素。
    6. 指针减去整数，同理移动的是整数个元素的距离。
    7. 指针求差，计算数组中两个元素之间相距几个元素。
    8. 指针比较，仅支持指向相同数据类型的指针。
    9. 一元运算符*的优先级要高于+，和++优先级相同但是结合律是从右往左，因此`*arr++`是`arr++`先求值，再解引用arr，相当于`*(arr++)`。如果是`(*arr)++`就是对arr指向的元素进行++运算。
    10. 虽然 ar[i] 和 *(ar+i) 是等价的只有当 ar 是指针变量时才能进行ar++，意思是说ar虽然是一个指针，但是不能对他进行赋值。
    - **注意**：不要解引用未初始化的指针，因为未初始化的指针的地址中可能含有未知数据，解引用可能会擦写未知位置的数据。
- 使用指针传递数组给函数
    ```c
    //int *ar 和 int ar[] 都表示ar是一个指向int元素的指针
    //int ar[]只能用于声明形式参数，提示ar指向的是一个int元素组成的数组 
    //以下四种函数声明都是等价的
    int sum(int *ar, int n);
    int sum(int *, int);
    int sum(int ar[], int n);
    int sum(int [], int);
    //但是函数定义中不能省略参数名。
    ```

- 保护数组中的数据

    在函数声明中使用const形式参数：`int sum(const int arr[], int n);`。这里的const只是告诉编译器该函数不能修改该指针指向的元素的内容，并不要求arr[]是常量。
    - 指向常量的指针：`const int *p`，指针p不能修改指向元素的内容但是p可以指向别处，p可以被赋予const和非const数据的地址，普通指针只能被赋予非const的数据的地址。
    - 不可以指向别的位置的指针：`int * const p`：p可以改变目标数据，但是不能指向别处。
    - 既不能指向别处，也不能改变目标元素的值：`const int * const p`。

- 指针和多维数组

    对于二维数组`int arr[4][2];`，根据之前的知识可以知道，arr[4][2]是一个由四个含有两个int元素的数组组成的数组，arr是该数组首元素的地址，该数组首元素是一个含有两个int元素的数组，由此我们可以进行以下推论：
    1. `arr = &arr[0]`，因为arr[0]是一个数组的名字，所以`arr[0] = &arr[0][0]`，因此虽然arr是两个int元素组成的对象的地址，arr[0]是一个int对象的地址，但是由于它们开始于相同的位置，`arr =arr[0]`。
    2. 对这arr和arr[0]进行加减运算时，由于两者指向的对象大小不同，地址移动的距离也是不同的。
    3. 因此对指针解引用或者对数组使用[]运算符时，有：`*arr = arr[0]`,`arr[0] = &arr[0][0]` --> `*arr = &arr[0][0]`，由此可知，arr是地址的地址，一次解引用得到的是一个地址，两次解引用后才能得到具体的值`**arr = arr[0][0]`。
    4. 根据以上三点，易知该二维数组使用指针寻找固定位置的方式为：`arr[2][1] = *(*(arr + 2) + 1)`。

- 指向多维数组的指针

    - 声明：`int (*p)[2]`，由于[]的优先级比*高，括号的作用就是先将p定义为一个指针，然后指向的元素含有两个int元素。如果写成`int *p[2]`，由于[]优先级高，因此p会被定义为一个数组名，数组p含有两个指向int元素的指针。
    - 使用，虽然p不是数组名，但是可以使用[]运算符：`*(*(p + m) + n) = p[m][n]`。

- 指针的兼容性

    首先是只有指向相同数据类型的指针才能互相赋值，其次是指向const和非const元素的指针之间的赋值，原则如下：
    非const指针只能接受非const地址或指针的赋值；const指针可以接受非const指针或元素地址的赋值。
    - 虽然const指针可以接受非const指针的赋值，但是如果const指针是指针的指针可以进行二次解引用的话，接受非const指针的赋值就是危险的，见下例：
    ```c
    int test(void)
    {
    const int **p;         //不能改变目标值的指针p
    int *p1;               //普通指针p1
    const int n = 10;      //常量n

    p = &p1;               //p可以接受非const指针地址的赋值
    *p = &n;               //指向常量的指针指向常量n，符合要求，但是此时的*p = p1，该语句相当于p1 = &n
    *p1 = 100;             //非const指针p1指向常量n，解引用p1就改变了n的值，这是违背初衷的
    }
    ```

- 函数和多维数组

    传递多维数组的形参
    ```c
    int arr [m][n][o];

    int sum(int pr[][n][o], int m);
    int sum(int (*pr)[n][0], int m);
    int sum(int [][n][o], int);
    //空的[]表示这是一个指针，m也可以写在[]里面，编译器会忽略它
    ```
    因为编译器会把数组转换成指针处理，所以`int sum(int arr[][][], int m);`这样的声明是错误的，因为编译器无法计算偏移量。
    
    除了以上方式，还可以使用typedef定义一个多维数组类型进行传递，详见typedef的使用。

- 变长数组（variable-length array，VLA）

    变长数组必须是自动存储类别，不能在声明中初始化。变长数组是可以通过变量确定数组的维度，但是一旦创建，数组的大小就不能再改变了。例如：
    ```c
    int a;
    int b;
    int varr[a][b];
    //不能在声明的时候进行初始化，因为此时并未实际创建数组，变长数组名实际上只是一个指针，函数只是用指针对原始数据进行处理。
    int sum(int rows, int cols, int ar[rows][cols]);
    //rows和cols必须在数组前面声明。
    ```
- 复合字面量（compound literal）

    复合字面量是除了符号常量之外的常量，字面量其实是首元素的地址，`int n = 5;`5就是一个int类型的字面量，`char m = 'A';`'A'就是一个char类型的字面量，对于数组`int arr[2] = {10,20};`，`(int [2]){10,20}`就是它的字面量。数组的复合字面量可以在向函数传递时不用创建数组，直接作为一个指针传入即可。

## 字符串和字符串函数

- 字符串字面量（字符串常量）

    双引号括起来的内容，在内存中是双引号中间的字符和编译器自动加上的'\0'字符。

    如果字符串字面量之间没有间隔或者用空白字符分隔，C语言会将其视为串联起来的字符串字面量。
    `"hello" "world" == "helloworld"`

    字符串常量属于静态存储类别，这说明在函数中使用字符串常量，该字符串只会被储存一次，在整个程序声明周期内存在。

    双引号括起来的字符串字面（包括双引号）被视为保存该字符串储存位置首元素的指针。

- 字符串初始化

    ```c
    const char arr[7] = "Hello!";
    //字符串数组中未被使用的元素都将被初始化为\0。
    const char arr[7] = {'H', 'e' 'l' 'l' 'o' '!' '\0'};
    //第二种初始化方式只有最后一个是\0才是字符串，否则就是一个字符数组。
    const char arr[] = "Hello!";
    //数组初始化声明的时候可以省略数组大小，编译器会自动计算，但是如果只是声明不初始化的话就必须指定大小。
    //用数组初始化字符串时，必须让编译器知道需要多少空间。
    const char *ptr = "Hello!";
    //因为字符串字面量是一个指针，因此可以直接用指针创建字符串。
    ```

- 数组形式和指针形式的异同

    两者可以进行数组操作和指针加法，但是由于数组名是常量，指针名是变量，只有指针可以进行递增操作。
    
    字符串字面量是静态存储类别，储存在静态存储区，作为执行文件的一部分储存在数据段中，当把程序载入内存时，也载入了程序中的字符串字面量。
    程序中初始化数组是将静态存储区中的字符串字面量保复制到数组中，初始化指针则是把字符串字面量的首元素地址复制给指针，因为字符串字面量是一个常量，因此在把指针初始化为字符串字面量时要使用const限定符。想要修改字符串就不要用指针指向字符串字面量。

- 字符串数组

    ```c
    const char *ptr[2] = {"hello", "hi"};
    //指向char指针的数组，占用空间小，工作效率高。
    char arr[2][6] = {"hello", "hi"};
    //两个6个字节大小的字符串的数组，可以改变字符串的内容。
    ```

- 字符串函数
    输入输出：`gets(), puts(); fgets(), fputs(); gets_s(); s_gets(); scanf(), printf()`
    其他字符串函数`string.h: strlen(), strcat(), strcmp(), strncmp(), strcpy(), strncpy()`

## 存储类别和内存管理

- 基础概念
    从硬件方面来看，被储存的每个值都占用一定的物理内存，C语言把这样的一块内存称为对象（object）。

    从软件方面来看，程序需要一种方法来访问对象，这可以通过声明变量来实现。

    `int a = 1;`该声明创建了一个叫做a的标识符，标识符是一个名称，用来指定硬件内存中的对象，在本例中还提供了储存在对象中的值。

    变量名并非指定对象的唯一途径，还可以用指针。`int *p = &a;`，在该声明中，p是一个标识符，它指定了一个储存地址的对象，*p表达式指定的是a所指定的对象，尽管*p不是一个标识符。一般而言，指定对象的表达式被称为左值，如果可以使用左值改变对象中的值，那这就是一个可修改的左值，常量或者字符串字面量这种虽然指定了对象但是无法修改，就是不可修改的左值。

    对象可以用存储期（storage duration）描述对象在内存中保留的时间，作用域（scope）和链接（linkage）描述程序中哪些部分可以访问它。

- 作用域

    - 块作用域：大括号中间的或者任意复合语句，其中函数的形式参数也是块作用域。

    - 函数作用域：仅用于goto语句，一个标签首次出现在函数的内层块中，它的作用域延伸到整个函数。

    - 函数原型作用域：函数声明时的形参标识符可以于定义时的标识符不同，因为声明时的作用域是函数原型作用域

    - 文件作用域：定义在所有函数外面的变量，可以被称为全局变量。

- 链接

    - 无链接：文件作用域的变量之外的其他变量都是无链接变量。

    - 外部链接：允许其他翻译单元的程序访问，普通的文件作用域变量具有这种属性。

    - 内部链接：只允许同一个翻译单元的程序访问，用static限定符进行声明的全局变量具有这种属性。

- 存储期

    - 静态存储期：文件作用域变量，程序运行期间一直存在。

    - 线程存储期：用于并发程序设计，程序执行可分为多个线程，具有线程存储期的对象，从被声明到线程结束一直存在。以关键字“_Thread_local”关键字声明一个对象时，每个线程都获得该变量的私有备份。

    - 自动存储期：块作用域变量，进入块时分配内存，退出块时释放内存变长数组，变长数组要更晚一些，在声明时才分配内存。

- 不考虑并发，五种存储类别如下

    存储类型|存储期|作用域|链接|声明方式
    :-:|:-:|:-:|:-:|:-
    自动|自动|块|无|块内声明
    寄存器|自动|块|无|块内，使用关键字register
    静态无链接|静态|块|无|块内，使用关键字static
    静态外部链接|静态|文件|外部|所有函数外声明
    静态内部链接|静态|文件|内部|所有函数外，使用关键字static

    1. 自动变量
    
        默认情况下，声明在块中和函数头中的任何变量都属于自动存储类别，当然也可以显式使用auto关键字，由于auto在C++中的用法和C中完全不同，所以编C/C++兼容的程序时不要用auto来表明这是一个自动变量。

        如果内层块中声明与外层块中相同名称的变量，内层快会隐藏外层块的定义，离开内层块之后，外层块变量的作用域又回到原来的作用域。

        对于if语句和for循环，条件判断部分和循环体构成一个块，循环体又是这个块的子块，因此判断部分会隐藏外部块的同名变量，循环体会隐藏判断部分的同名变量。

        自动变量不会自动初始化，必须显式初始化，可以使用非常量表达式对它进行初始化，前提是表达式中的变量在前面已经定义过。

    2. 寄存器变量
        
        使用register关键字请求将数据放在寄存器中，但是请求不一定被批准，但是无论最终存在哪里，都无法获得该变量的地址。可声明为register变量的数据类型必须能够在cpu的寄存器里放得下。

    3. 块作用域的静态变量（静态无链接的变量）

        该变量在内存中保持不动，不会随着块结束被销毁。块中的静态变量声明语句`static int n = 0;`并非块的一部分，意即程序在运行到该位置时并不会进行创建变量的操作，因为静态变量早在程序载入时就已经创建完毕并存储在静态存储区了，块中的语句只是表明该变量的作用域是该块。

    4. 外部链接的静态变量

        把变量的**定义式声明**放在所有函数外即可获得此种变量，只能初始化一次，必须在定义式声明的同时进行初始化。

        只能使用常量表达式进行初始化，如果不进行初始化会自动初始化为0。
        
        在函数中可以使用存储类别说明符extern进行**引用式声明**，表示函数要使用这个全局变量。extern告诉编译器，该变量来自一个函数外部定义的变量。如果是引用式声明一个数组，数组大小可以省略，在函数中引用式声明可以不写，但是如果不使用extern关键字，而是普通地声明一个与全局变量相同的变量，会在函数内创建一个局部变量，并且隐藏同名的全局变量。如果定义式声明不在本翻译单元内，引用式声明不能省略。

    5. 内部链接的静态变量

        不能被其他翻译单元的程序访问。

- 函数的存储类别

    1. 外部函数：默认存储类别，可以被其他文件访问；
        ```c
        int alpha(int);
        ```
        ```c
        extern int alpha(int);
        //声明定义在其他文件中的函数
        ```

    2. 静态函数：只能用于其定义所在的文件；
        ```c
        static int beta(int);
        ```
    
    3. 内联函数，暂时不研究

- 分配内存

    - malloc()函数

## 结构
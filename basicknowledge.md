# C

[toc]

## Array & Pointer
- 概念：一系列类型相同的元素组成的结构就是数组。`type name[number]`
- 指定初始化器（C99）
    ```c
    int arr[6] = {[2]=2,1,0};//将第3个元素初始化为2，1和0将按顺序初始化初始化器之后的元素
    ```
- 多维数组：就是元素是数组的数组，声明和初始化方法以二维数组为例：
    ```c
    int num[3][3] = 
    {
        {1,2,3},
        {4,5,6},
        (7,8,9)
    };
    ```
- 指针和数组，数组名就是数组首元素的地址`arr == &arr[0]`

    1. 赋值：数组名、带地址运算符（&）的变量名以及另一个指针都可以对指针进行赋值。
    2. 使用运算符“*”解引用，不必多说。
    3. 使用运算符“&”取得指针本身的地址。
    4. 指针与整数相加或者整数与指针相加，增加的具体数值是“数字×指向元素所需的字节数”：`arr + 1 == &arr[1]; *(arr + 1) == arr[1]`。
    5. 指针递增（++）和递减（--），如果指向的是数组中的一个元素，运算后将指向下一个或者上一个元素。
    6. 指针减去整数，同理移动的是整数个元素的距离。
    7. 指针求差，计算数组中两个元素之间相距几个元素。
    8. 指针比较，仅支持指向相同数据类型的指针。
    9. 一元运算符*的优先级要高于+，和++优先级相同但是结合律是从右往左，因此`*arr++`是`arr++`先求值，再解引用arr，相当于`*(arr++)`。如果是`(*arr)++`就是对arr指向的元素进行++运算。
    10. 虽然 ar[i] 和 *(ar+i) 是等价的只有当 ar 是指针变量时才能进行ar++，意思是说ar虽然是一个指针，但是不能对他进行赋值。
    - **注意**：不要解引用未初始化的指针，因为未初始化的指针的地址中可能含有未知数据，解引用可能会擦写未知位置的数据。
- 使用指针传递数组给函数
    ```c
    //int *ar 和 int ar[] 都表示ar是一个指向int元素的指针
    //int ar[]只能用于声明形式参数，提示ar指向的是一个int元素组成的数组 
    //以下四种函数声明都是等价的
    int sum(int *ar, int n);
    int sum(int *, int);
    int sum(int ar[], int n);
    int sum(int [], int);
    //但是函数定义中不能省略参数名。
    ```

- 保护数组中的数据

    在函数声明中使用const形式参数：`int sum(const int arr[], int n);`。这里的const只是告诉编译器该函数不能修改该指针指向的元素的内容，并不要求arr[]是常量。
    - 指向常量的指针：`const int *p`，指针p不能修改指向元素的内容但是p可以指向别处，p可以被赋予const和非const数据的地址，普通指针只能被赋予非const的数据的地址。
    - 不可以指向别的位置的指针：`int * const p`：p可以改变目标数据，但是不能指向别处。
    - 既不能指向别处，也不能改变目标元素的值：`const int * const p`。

- 指针和多维数组

    对于二维数组`int arr[4][2];`，根据之前的知识可以知道，arr[4][2]是一个由四个含有两个int元素的数组组成的数组，arr是该数组首元素的地址，该数组首元素是一个含有两个int元素的数组，由此我们可以进行以下推论：
    1. `arr = &arr[0]`，因为arr[0]是一个数组的名字，所以`arr[0] = &arr[0][0]`，因此虽然arr是两个int元素组成的对象的地址，arr[0]是一个int对象的地址，但是由于它们开始于相同的位置，`arr =arr[0]`。
    2. 对这arr和arr[0]进行加减运算时，由于两者指向的对象大小不同，地址移动的距离也是不同的。
    3. 因此对指针解引用或者对数组使用[]运算符时，有：`*arr = arr[0]`,`arr[0] = &arr[0][0]` --> `*arr = &arr[0][0]`，由此可知，arr是地址的地址，一次解引用得到的是一个地址，两次解引用后才能得到具体的值`**arr = arr[0][0]`。
    4. 根据以上三点，易知该二维数组使用指针寻找固定位置的方式为：`arr[2][1] = *(*(arr + 2) + 1)`。

- 指向多维数组的指针

    - 声明：`int (*p)[2]`，由于[]的优先级比*高，括号的作用就是先将p定义为一个指针，然后指向的元素含有两个int元素。如果写成`int *p[2]`，由于[]优先级高，因此p会被定义为一个数组名，数组p含有两个指向int元素的指针。
    - 使用，虽然p不是数组名，但是可以使用[]运算符：`*(*(p + m) + n) = p[m][n]`。

- 指针的兼容性

    首先是只有指向相同数据类型的指针才能互相赋值，其次是指向const和非const元素的指针之间的赋值，原则如下：
    非const指针只能接受非const地址或指针的赋值；const指针可以接受非const指针或元素地址的赋值。
    - 虽然const指针可以接受非const指针的赋值，但是如果const指针是指针的指针可以进行二次解引用的话，接受非const指针的赋值就是危险的，见下例：
    ```c
    int test(void)
    {
    const int **p;         //不能改变目标值的指针p
    int *p1;               //普通指针p1
    const int n = 10;      //常量n

    p = &p1;               //p可以接受非const指针地址的赋值
    *p = &n;               //指向常量的指针指向常量n，符合要求，但是此时的*p = p1，该语句相当于p1 = &n
    *p1 = 100;             //非const指针p1指向常量n，解引用p1就改变了n的值，这是违背初衷的
    }
    ```

- 函数和多维数组

    传递多维数组的形参
    ```c
    int arr [m][n][o];

    int sum(int pr[][n][o], int m);
    int sum(int (*pr)[n][0], int m);
    int sum(int [][n][o], int);
    //空的[]表示这是一个指针，m也可以写在[]里面，编译器会忽略它
    ```
    因为编译器会把数组转换成指针处理，所以`int sum(int arr[][][], int m);`这样的声明是错误的，因为编译器无法计算偏移量。
    
    除了以上方式，还可以使用typedef定义一个多维数组类型进行传递，详见typedef的使用。

- 变长数组（variable-length array，VLA）

    变长数组必须是自动存储类别，不能在声明中初始化。变长数组是可以通过变量确定数组的维度，但是一旦创建，数组的大小就不能再改变了。例如：
    ```c
    int a;
    int b;
    int varr[a][b];
    //不能在声明的时候进行初始化，因为此时并未实际创建数组，变长数组名实际上只是一个指针，函数只是用指针对原始数据进行处理。
    int sum(int rows, int cols, int ar[rows][cols]);
    //rows和cols必须在数组前面声明。
    ```
- 复合字面量（compound literal）

    复合字面量是除了符号常量之外的常量，字面量其实是首元素的地址，`int n = 5;`5就是一个int类型的字面量，`char m = 'A';`'A'就是一个char类型的字面量，对于数组`int arr[2] = {10,20};`，`(int [2]){10,20}`就是它的字面量。数组的复合字面量可以在向函数传递时不用创建数组，直接作为一个指针传入即可。

## 字符串和字符串函数

- 字符串字面量（字符串常量）

    双引号括起来的内容，在内存中是双引号中间的字符和编译器自动加上的'\0'字符。

    如果字符串字面量之间没有间隔或者用空白字符分隔，C语言会将其视为串联起来的字符串字面量。
    `"hello" "world" == "helloworld"`

    字符串常量属于静态存储类别，这说明在函数中使用字符串常量，该字符串只会被储存一次，在整个程序声明周期内存在。

    双引号括起来的字符串字面（包括双引号）被视为保存该字符串储存位置首元素的指针。

- 字符串初始化

    ```c
    const char arr[7] = "Hello!";
    //字符串数组中未被使用的元素都将被初始化为\0。
    const char arr[7] = {'H', 'e' 'l' 'l' 'o' '!' '\0'};
    //第二种初始化方式只有最后一个是\0才是字符串，否则就是一个字符数组。
    const char arr[] = "Hello!";
    //数组初始化声明的时候可以省略数组大小，编译器会自动计算，但是如果只是声明不初始化的话就必须指定大小。
    //用数组初始化字符串时，必须让编译器知道需要多少空间。
    const char *ptr = "Hello!";
    //因为字符串字面量是一个指针，因此可以直接用指针创建字符串。
    ```

- 数组形式和指针形式的异同

    两者可以进行数组操作和指针加法，但是由于数组名是常量，指针名是变量，只有指针可以进行递增操作。
    
    字符串字面量是静态存储类别，储存在静态存储区，作为执行文件的一部分储存在数据段中，当把程序载入内存时，也载入了程序中的字符串字面量。
    程序中初始化数组是将静态存储区中的字符串字面量保复制到数组中，初始化指针则是把字符串字面量的首元素地址复制给指针，因为字符串字面量是一个常量，因此在把指针初始化为字符串字面量时要使用const限定符。想要修改字符串就不要用指针指向字符串字面量。

- 字符串数组

    ```c
    const char *ptr[2] = {"hello", "hi"};
    //指向char指针的数组，占用空间小，工作效率高。
    char arr[2][6] = {"hello", "hi"};
    //两个6个字节大小的字符串的数组，可以改变字符串的内容。
    ```

- 字符串函数
    输入输出：`gets(), puts(); fgets(), fputs(); gets_s(); s_gets(); scanf(), printf()`
    其他字符串函数`string.h: strlen(), strcat(), strcmp(), strncmp(), strcpy(), strncpy()`

## 存储类别和内存管理

- 基础概念
    从硬件方面来看，被储存的每个值都占用一定的物理内存，C语言把这样的一块内存称为对象（object）。

    从软件方面来看，程序需要一种方法来访问对象，这可以通过声明变量来实现。

    `int a = 1;`该声明创建了一个叫做a的标识符，标识符是一个名称，用来指定硬件内存中的对象，在本例中还提供了储存在对象中的值。

    变量名并非指定对象的唯一途径，还可以用指针。`int *p = &a;`，在该声明中，p是一个标识符，它指定了一个储存地址的对象，*p表达式指定的是a所指定的对象，尽管*p不是一个标识符。一般而言，指定对象的表达式被称为左值，如果可以使用左值改变对象中的值，那这就是一个可修改的左值，常量或者字符串字面量这种虽然指定了对象但是无法修改，就是不可修改的左值。

    对象可以用存储期（storage duration）描述对象在内存中保留的时间，作用域（scope）和链接（linkage）描述程序中哪些部分可以访问它。

- 作用域

    - 块作用域：大括号中间的或者任意复合语句，其中函数的形式参数也是块作用域。

    - 函数作用域：仅用于goto语句，一个标签首次出现在函数的内层块中，它的作用域延伸到整个函数。

    - 函数原型作用域：函数声明时的形参标识符可以于定义时的标识符不同，因为声明时的作用域是函数原型作用域

    - 文件作用域：定义在所有函数外面的变量，可以被称为全局变量。

- 链接

    - 无链接：文件作用域的变量之外的其他变量都是无链接变量。

    - 外部链接：允许其他翻译单元的程序访问，普通的文件作用域变量具有这种属性。

    - 内部链接：只允许同一个翻译单元的程序访问，用static限定符进行声明的全局变量具有这种属性。

- 存储期

    - 静态存储期：文件作用域变量，程序运行期间一直存在。

    - 线程存储期：用于并发程序设计，程序执行可分为多个线程，具有线程存储期的对象，从被声明到线程结束一直存在。以关键字“_Thread_local”关键字声明一个对象时，每个线程都获得该变量的私有备份。

    - 自动存储期：块作用域变量，进入块时分配内存，退出块时释放内存变长数组，变长数组要更晚一些，在声明时才分配内存。

- 不考虑并发，五种存储类别如下

    存储类型|存储期|作用域|链接|声明方式
    :-:|:-:|:-:|:-:|:-
    自动|自动|块|无|块内声明
    寄存器|自动|块|无|块内，使用关键字register
    静态无链接|静态|块|无|块内，使用关键字static
    静态外部链接|静态|文件|外部|所有函数外声明
    静态内部链接|静态|文件|内部|所有函数外，使用关键字static

    1. 自动变量
    
        默认情况下，声明在块中和函数头中的任何变量都属于自动存储类别，当然也可以显式使用auto关键字，由于auto在C++中的用法和C中完全不同，所以编C/C++兼容的程序时不要用auto来表明这是一个自动变量。

        如果内层块中声明与外层块中相同名称的变量，内层快会隐藏外层块的定义，离开内层块之后，外层块变量的作用域又回到原来的作用域。

        对于if语句和for循环，条件判断部分和循环体构成一个块，循环体又是这个块的子块，因此判断部分会隐藏外部块的同名变量，循环体会隐藏判断部分的同名变量。

        自动变量不会自动初始化，必须显式初始化，可以使用非常量表达式对它进行初始化，前提是表达式中的变量在前面已经定义过。

    2. 寄存器变量
        
        使用register关键字请求将数据放在寄存器中，但是请求不一定被批准，但是无论最终存在哪里，都无法获得该变量的地址。可声明为register变量的数据类型必须能够在cpu的寄存器里放得下。

    3. 块作用域的静态变量（静态无链接的变量）

        该变量在内存中保持不动，不会随着块结束被销毁。块中的静态变量声明语句`static int n = 0;`并非块的一部分，意即程序在运行到该位置时并不会进行创建变量的操作，因为静态变量早在程序载入时就已经创建完毕并存储在静态存储区了，块中的语句只是表明该变量的作用域是该块。

    4. 外部链接的静态变量

        把变量的**定义式声明**放在所有函数外即可获得此种变量，只能初始化一次，必须在定义式声明的同时进行初始化。

        只能使用常量表达式进行初始化，如果不进行初始化会自动初始化为0。
        
        在函数中可以使用存储类别说明符extern进行**引用式声明**，表示函数要使用这个全局变量。extern告诉编译器，该变量来自一个函数外部定义的变量。如果是引用式声明一个数组，数组大小可以省略，在函数中引用式声明可以不写，但是如果不使用extern关键字，而是普通地声明一个与全局变量相同的变量，会在函数内创建一个局部变量，并且隐藏同名的全局变量。如果定义式声明不在本翻译单元内，引用式声明不能省略。

    5. 内部链接的静态变量

        不能被其他翻译单元的程序访问。

- 函数的存储类别

    1. 外部函数：默认存储类别，可以被其他文件访问；
        ```c
        int alpha(int);
        ```
        ```c
        extern int alpha(int);
        //声明定义在其他文件中的函数
        ```

    2. 静态函数：只能用于其定义所在的文件；
        ```c
        static int beta(int);
        ```
    
    3. 内联函数，暂时不研究

- 分配内存

    - malloc()函数
    
        接受需要分配的字节数为参数，分配好内存后返回内存块首字节的地址，这样分配的对象是匿名的，malloc分配内存但是不会为其赋名。

        返回的指针是指向void的通用指针，可以赋值给任意类型的指针变量而不用考虑类型匹配的问题，为了代码的可读性，可以使用强制类型转换。

        如果malloc函数分配内存失败，将会返回空指针，此时可以使用exit函数退出程序。

        使用malloc函数创建数组，创建数组有三种方法：

        - 用常量表达式表示数组的维度，用数组名访问数组元素，可以用静态内存或者动态内存创建这种数组；
        - 变长数组，用变量表达式来表示数组维度，用数组名访问数组元素，只能在自动内存中创建；
        - 声明一个指针，调用malloc函数申请内存，将返回值赋给指针，使用指针访问数组，指针的存储类型可以是静态或自动的。

    - free()函数

        参数是malloc返回的地址，他会释放malloc分配的内存，如果malloc申请的内存一直不释放，可能会耗尽所有内存，这类问题成为内存泄漏（memory leak）。

    - calloc函数

        需要两个参数，第一个是所需存储单元的数量，第二个是单个存储单元的字节数，它在分配内存时会把块中所有的位都改为0。其他性质和malloc一样。

- 类型限定符

    变量除了用数据类型和存储类别来描述外，还有恒常性（constancy）和易变性（volatility）等性质。由类型限定符const、volatile、restrict、_Atomic进行声明。C99标准为类型限定符增加了幂等（idempotent）属性，即声明中可以多次用同一个限定符，但是只用一次，多余的会被忽略。

    - const类型限定符

        以const关键字声明的对象，其值不能通过赋值、递增递减来改变。常见用法如下：

        1. 在指针和形参声明中使用const
        
            数组和指针部分已经讲过如何对指针使用const限定符。对于函数形参，因为传递到函数的参数本质上就是复制一份原始数据然后赋值给函数的局部变量，因此如果函数不需要改变参数值或者不希望函数能够改变参数值就可以使用const来声明形参，尤其是在形参是指针的时候，可以防止外部变量被函数不慎修改。
        2. 对全局变量使用const

            方法一
            ```c
            /* file1.c -- 定义了一些外部const变量 */
            const double PI = 3.14159;
            const char *MONTHS[12] = {"January", "February", "March", "April", "May","June", "July", "August", "September", "October","November", "December"};

            /* file2.c -- 使用定义在file1.c中的外部const变量 */
            extern const double PI;
            extern const *MONTHS[];
            ```

            方法二
            ```c
            /* constant.h -- 定义了一些外部const变量 */
            static const double PI = 3.14159;
            static const char *MONTHS[12] = {"January", "February", "March", "April", "May","June", "July", "August", "September", "October","November", "December"};

            /* file1.c --使用定义在别处的外部const变量*/
            #include "constant.h" //双引号代表在本地寻找头文件

            /* file2.c --使用定义在别处的外部const变量*/
            #include "constant.h"
            ```
            使用头文件声明外部变量时，必须使用static声明内部链接的全局变量，因为所有用到头文件的代码文件都会复制一份头文件中的变量声明，如果不用static的话所有文件中都会有一份相同标识符的定义式声明，C语言不允许这样。使用了static其他文件就不会互相访问这些来自头文件的声明了。

            虽然使用头文件声明全局变量很方便，但是会浪费内存空间。

    - volatile类型限定符

        表示代理（而不是变量所在的程序）可以改变该变量的值，不加这个限定符其实代理也可以改变，加上是为了告诉编译器虽然程序可能没有改变这个变量的值，但是有代理改变了变量的值，因此不要随便优化关于这个变量的代码。

        可以用const和volatile同时限定一个值，表示一个程序不会改变但是代理会改变的值。两个限定符在声明时的前后顺序不重要。

    - restrict类型限定符

        只用于指针，表示这个指针是访问数据对象唯一且原始的方式。也是用于告诉编译器和读者该指针有这样的性质，用于代码的优化，但是实际情况如何编译器并不会去确认。

        用于函数的形参声明，表示在函数体中没有其他标识符可以修改该指针指向的数据。

    - _Atomic类型限定符

        原子类型。用于并发编程，此处不研究。

    - 旧关键字的新位置

        ```c
        //以前的风格
        void of_month(int * const a1, int * restrict a2, int n);
        //C99允许
        void of_month(int a1[const], int a2[restrict], int n);
        
        //static的新用法：
        //arr是一个指向数组首元素的指针，且该数组至少有20个double   元素
        double stick(double arr[static 20]);
        ```


## 结构（结构布局和结构变量）

- 结构声明
    ```c
    struct book {
        char title[MAX_TITLE];
        char author[MAX_AUTHOR];
        float value;
    };
    //不要遗漏 “}” 后的分号。
    ```
    该声明并未创建实际对象，只描述了该对象由什么元素组成（有时候把结构声明成为模板），struct关键字表示后面是一个结构，它后面是一个**可选的标记**，以便后续的程序使用该标记引用该模板：`struct book library;`，如果struct后面没有标记，那么不可以使用这种方式声明结构变量。

    声明可以放在函数内部，仅供函数内部使用，也可以放在函数外部，那么所有函数都可以使用。

- 定义结构变量

    ```C
    //如果之前已经进行了结构声明，可以这么声明结构变量
    struct book library;
    //其本质是下面这种声明的简化版
    struct book {
        char title[MAX_TITLE];
        char author[MAX_AUTHOR];
        float value;
    } library;
    //也可以不使用结构标记，直接声明结构变量，但是没有标记的模板不能重复使用
    struct {
        char title[MAX_TITLE];
        char author[MAX_AUTHOR];
        float value;
    } library;
    ```

- 初始化结构

    与数组的初始化相似的：
    ```C
    struct book library = {
        "test_name",
        "test_author",
        1.00
    };
    ```
    各项之间用逗号分隔即可，为了提高可读性才选择每个成员占据一行。

- 访问结构成员

    结构成员运算符“.”，`library.title`。.title相当于library的下标。

- 结构的初始化器

    和数组的初始化规则一样，示例如下：
    ```c
    //初始化任意成员
    struct book book_name = {.value = 1};

    //按照任意顺序初始化结构成员
    struct book book_name = {.value = 10, .author = "Tom", .title = "A_book"};

    //指定初始化后面使用普通初始化，初始化的是指定初始化成员后面的成员，对特定成员的最后一次赋值才是它实际获得的值
    struct book book_name = {.value = 10, .author = "Tom", 20};
    //在本例中，初始化之后value的值是20
    ```

- 结构数组

    声明结构数组`struct book library[MAX];`。
    标识结构数组的成员：
    ```c
    library              //名叫library成员是book的结构数组
    library[2]           //结构数组library的第3个元素
    library[2].title     //结构数组library的第3个元素的title成员
    library[2].title[4]  //结构数组library第3个元素的title成员的第5个字符
    ```

- 嵌套结构

    ```c
    //第一个结构
    struct name {
        char first_name[20];
        char last_name[20];
    };
    //第二个结构
    struct book {
        char title[MAX_TITLE];
        struct name author;
        float value;
    };
    //定义并初始化结构变量
    struct book library = {"book_name", {"Tom","Winter"}, 10};
    //访问嵌套的结构成员
    char library_author[10] = library.author.first_name;
    ```

- 指向结构的指针

    ```c
    //声明和初始化
    struct book * book_name;
    book_name = &library;  //结构变量名并不是结构的地址
    
    //用指针访问结构成员
    book_name->title;
    (*book_name).title;  //*运算符的优先级高于.运算符。
    ```

- 向函数传递结构

    - 直接传递结构成员
    - 形参设为指向结构的指针然后传递结构的地址，使用结构数组的函数可以用数组名作为数组的第一个结构的地址进行传参
    - 结构可以作为形参就可以直接传递结构
    - 可以把一个结构赋给另一个相同类型的结构，即使成员里有数组也行。因此函数可以将结构作为返回值。

- 结构中的字符串数组和字符串指针

    在结构中使用字符串数组，字符串储存在结构内部，使用字符串指针的话，结构内部只存储字符串的地址，因此如果在结构中使用字符串指针的话，最好只用来在程序中管理那些已经分配好存储位置的字符串，如果直接解引用字符串指针进行初始化可能会将字符串存放到不该放的位置。

- 结构的复合字面量

    如果只需要一个临时的结构值，可以使用复合字面量：
    
    `(struct book) {"book_name", "author_name", 90};`可以用于传参赋值等等，复合字面量如果在所有函数的外部那么它具有静态存储期，如果在块内就具有自动存储期。

- 伸缩型数组成员

    C99新增的特性，该数组不会立即存在，但是该数组可以编写任何代码，就好像他确实存在而且拥有需要的元素数目一样。

    声明伸缩型数组成员：
    
    - 伸缩型数组成员必须是结构中的最后一个成员；
    - 结构中必须至少有一个成员；
    - 伸缩型数组的声明类似于普通数组，其方括号内是空的。
    ```c
    struct flex
    {
        int count;
        double scores[];
    };

    //使用的时候不要用它来声明结构变量，而是声明一个指向结构的指针然后用malloc来分配需要的内存空间
    struct flex * pf;
    pf = malloc(sizeof(struct flex) + 5 * sizeof(double));
    ```
    一些特殊要求：
    1. 不能用有伸缩型数组的结构进行赋值或者拷贝，实在需要拷贝，用memcpy()函数；
    2. 不要以按值方式传递这种结构；
    3. 带伸缩型数组的结构不能作为数组或其他结构的成员。

- 匿名结构（C11）

    在嵌套结构时使用匿名结构，外层结构可以直接使用内层结构的成员
    ```c
    struct person
    {
        int id;
        struct {char first[20]; char last[20];};
    };
    //初始化一个person结构
    struct person ted ={886,{"Ted","Grass"}};
    //直接访问内层结构成员，和没有内层结构的用法是一样的。
    puts(ted.first);
    ```
- 联合（union）

    联合是一种数据类型，它可以在同一个内存空间中存储不同类型的数据，但是并非同时存储。
    ```c
    //联合的声明和结构是一样的
    union hold {
        int digit;
        double big;
        char letter;
    };
    //创建一个hold类型的联合变量
    union hold fit;
    //创建10个hold类型的联合变量组成的数组
    union hold save[10];
    //创建指向hold类型的联合变量的指针
    union hold * pu;

    //联合的初始化
    union hold valA;                    //创建联合变量
    valA.letter = 'R';                  //初始化联合变量
    union hold valB = valA;             //用另一个联合变量进行初始化
    union hold valC = {88};             //初始化digit
    union hold calD = {.big = 118.3};   //联合的指定初始化器
    ```

    联合的用法：
    ```c
    //把23存在fit中
    fit.digit = 23;
    //清除原先的23，存入2.0
    fit.big = 2.0
    //清除2.0存入H
    fit.letter = 'H';
    //使用指针访问联合变量，方法和结构一样
    union hold * pu;
    pu = &fit;
    x = pu->digit; //相当于x = fit.digit
    
    //匿名联合，用法和匿名结构相同，此处不举例了。
    ```

- 枚举类型
